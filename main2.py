import numpy as np


def svd(A, eps=1e-10, max_iter=1000):
    """
    Вычисляет сингулярное разложение матрицы A = U @ Sigma @ V.T
    с использованием метода двусторонних вращений Якоби

    Параметры:
    A -- входная матрица (m x n)
    eps -- точность для определения сходимости (по умолчанию 1e-10)
    max_iter -- максимальное количество итераций (по умолчанию 1000)

    Возвращает:
    U -- унитарная матрица левых сингулярных векторов (m x m)
    Sigma -- диагональная матрица сингулярных значений (m x n)
    V.T -- транспонированная унитарная матрица правых сингулярных векторов (n x n)

    Алгоритм:
    1. Инициализация U, V как единичных матриц
    2. Итеративное применение вращений Якоби к строкам и столбцам
    3. Проверка сходимости по величине недиагональных элементов
    4. Извлечение сингулярных значений из диагонали
    5. Нормализация сингулярных векторов
    """
    m, n = A.shape
    # Инициализация U как единичной матрицы размера m x m
    U = np.eye(m)
    # Инициализация V как единичной матрицы размера n x n
    V = np.eye(n)
    # Создаем копию входной матрицы для преобразований
    S = A.copy().astype(float)

    # Основной цикл итераций
    for _ in range(max_iter):
        converged = True  # Флаг сходимости

        # Фаза 1: Обработка столбцов (приведение к диагональной форме слева)
        for i in range(min(m, n)):  # Для каждого столбца
            for j in range(i + 1, n):  # И для каждого следующего столбца
                # Вычисляем элементы для вращения
                x = S[:, i]  # Текущий столбец i
                y = S[:, j]  # Следующий столбец j
                # Вычисляем скалярные произведения
                a, b, c = x.dot(x), x.dot(y), y.dot(y)

                # Вычисляем угол вращения (аналогично методу Якоби)
                if abs(b) > eps:  # Если есть что обнулять
                    zeta = (c - a) / (2 * b)
                    # Вычисляем тангенс угла вращения
                    t = np.sign(zeta) / (abs(zeta) + np.sqrt(1 + zeta ** 2))
                    # Вычисляем косинус и синус угла
                    cos = 1 / np.sqrt(1 + t ** 2)
                    sin = cos * t
                else:
                    cos, sin = 1, 0  # Вращение не требуется

                # Применяем вращение, если оно существенно
                if abs(sin) > eps:
                    converged = False  # Показываем, что сходимость не достигнута

                    # Обновляем матрицу S: применяем вращение к столбцам i и j
                    S[:, i], S[:, j] = cos * S[:, i] + sin * S[:, j], -sin * S[:, i] + cos * S[:, j]

                    # Обновляем матрицу V: накапливаем преобразования
                    V[:, i], V[:, j] = cos * V[:, i] + sin * V[:, j], -sin * V[:, i] + cos * V[:, j]

        # Фаза 2: Обработка строк (приведение к диагональной форме справа)
        for i in range(min(m, n)):  # Для каждой строки
            for j in range(i + 1, m):  # И для каждой следующей строки
                # Вычисляем элементы для вращения
                x = S[i, :]  # Текущая строка i
                y = S[j, :]  # Следующая строка j
                # Вычисляем скалярные произведения
                a, b, c = x.dot(x), x.dot(y), y.dot(y)

                # Вычисляем угол вращения
                if abs(b) > eps:  # Если есть что обнулять
                    zeta = (c - a) / (2 * b)
                    # Вычисляем тангенс угла вращения
                    t = np.sign(zeta) / (abs(zeta) + np.sqrt(1 + zeta ** 2))
                    # Вычисляем косинус и синус угла
                    cos = 1 / np.sqrt(1 + t ** 2)
                    sin = cos * t
                else:
                    cos, sin = 1, 0  # Вращение не требуется

                # Применяем вращение, если оно существенно
                if abs(sin) > eps:
                    converged = False  # Показываем, что сходимость не достигнута

                    # Обновляем матрицу S: применяем вращение к строкам i и j
                    S[i, :], S[j, :] = cos * S[i, :] + sin * S[j, :], -sin * S[i, :] + cos * S[j, :]

                    # Обновляем матрицу U: накапливаем преобразования
                    U[:, i], U[:, j] = cos * U[:, i] + sin * U[:, j], -sin * U[:, i] + cos * U[:, j]

        # Проверка условия сходимости
        if converged:
            break  # Выход, если достигнута сходимость

    # Извлечение сингулярных значений из диагонали S
    sigma = np.zeros(min(m, n))
    for i in range(min(m, n)):
        sigma[i] = np.linalg.norm(S[:, i]) if i < n else 0

    # Создание диагональной матрицы Sigma
    Sigma = np.zeros((m, n))
    np.fill_diagonal(Sigma, sigma)

    # Нормализация сингулярных векторов
    for i in range(min(m, n)):
        if sigma[i] > eps:  # Нормализуем только существенные векторы
            U[:, i] /= np.linalg.norm(U[:, i])
            V[:, i] /= np.linalg.norm(V[:, i])

    return U, Sigma, V.T


def pseudo_inverse(A, eps=1e-10):
    """
    Вычисляет псевдообратную матрицу с использованием SVD

    Параметры:
    A -- входная матрица (m x n)
    eps -- порог для определения нулевых сингулярных значений (по умолчанию 1e-10)

    Возвращает:
    Псевдообратную матрицу (n x m)

    Алгоритм:
    1. Вычисление SVD: A = U @ Sigma @ V.T
    2. Инверсия ненулевых сингулярных значений
    3. Вычисление A⁺ = V @ Sigma⁺ @ U.T
    """
    # Вычисляем SVD матрицы A
    U, Sigma, Vt = svd(A, eps)
    m, n = A.shape

    # Создаем псевдообратную диагональную матрицу
    Sigma_pinv = np.zeros((n, m))  # Размерность обратна исходной
    for i in range(min(m, n)):
        if Sigma[i, i] > eps:  # Инвертируем только значимые сингулярные значения
            Sigma_pinv[i, i] = 1 / Sigma[i, i]

    # Вычисляем псевдообратную матрицу по формуле
    A_pinv = Vt.T @ Sigma_pinv @ U.T

    return A_pinv


# Демонстрация работы программы
if __name__ == "__main__":
    # Тестовая матрица 3x3
    A = np.array([[1, 2, 5],
                  [3, 4, 8],
                  [5, 6, 12]], dtype=float)

    print("Исходная матрица:")
    print(A)

    # Вычисление SVD
    print("\nВычисление SVD...")
    U, Sigma, Vt = svd(A)

    print("\nМатрица U (левые сингулярные векторы):")
    print(U)
    print("\nМатрица Sigma (сингулярные значения на диагонали):")
    print(Sigma)
    print("\nМатрица V транспонированная (правые сингулярные векторы):")
    print(Vt)

    # Проверка корректности SVD: A ≈ U @ Sigma @ Vt
    print("\nПроверка SVD (A ≈ U @ Sigma @ Vt):")
    reconstructed_A = U @ Sigma @ Vt
    print(reconstructed_A)
    print("\nНорма разности:", np.linalg.norm(A - reconstructed_A))

    # Вычисление псевдообратной матрицы
    print("\nВычисление псевдообратной матрицы...")
    A_pinv = pseudo_inverse(A)
    print("\nПсевдообратная матрица A⁺:")
    print(A_pinv)

    # Проверка свойств псевдообратной матрицы
    print("\nПроверка свойства 1: A @ A⁺ @ A ≈ A")
    print(A @ A_pinv @ A)
    print("Норма разности:", np.linalg.norm(A - (A @ A_pinv @ A)))

    print("\nПроверка свойства 2: A⁺ @ A @ A⁺ ≈ A⁺")
    print(A_pinv @ A @ A_pinv)
    print("Норма разности:", np.linalg.norm(A_pinv - (A_pinv @ A @ A_pinv)))